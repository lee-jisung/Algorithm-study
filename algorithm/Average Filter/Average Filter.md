# Average Filter Algorithm (평균 필터 알고리즘)

 실시간 데이터의 평균을 효율적으로 구하는 방법
 
  - 서버 엔진의 액세스 로그에 쌓이는 응답들의 평균 응답 시간을 구하기
  
  - 센서에 들어오는 값들의 평균 구하기 등등...
 
 
## 일반적인 산술 평균


#### 일반적인 산술 평균 구하는 방법 
 
 > Average(n) = (x1 + x2 + x3 ... + xn) / n 
 
 이렇게 데이터를 모두 모아서 한번에 연산하는 방식을 배치식(Batch Expression)이라고 한다
 
 이 베치식의 단점은 시간 복잡도가 O(n)이라는 것. 이건 데이터의 숫자가 적을 때는 큰 문제가 없더라도 계속 해서 누적 되는 실시간
 데이터를 처리해야 하는 시스템에서는 치명적인 단점이 됨.
 
 또한, 시간이 단순히 시간이 오래걸린다는 것이 아니라 데이터가 늘어나면 수행 시간도 비례해서 늘어난다는 것이다. 또한, N번째 데이터까지 합친
 평균을 계산할 때 이전 평균 계산 결과를 전혀 사용하지 못하기 때문에 결국 지금까지 들어온 모든 데이터를 저장하고 있어야 하며, 이 때 불필요한
 메모리 자원도 낭비된다. 데이터가 늘어나도 언제나 수행 속도가 O(1)인 평균 알고리즘이 있을까?
 
 
## 평균 필터 알고리즘

 바로 평균 필터 알고리즘. 이 알고리즘은 'n'번째 데이터가 들어온 데이터 셋의 평균을 구할 때 'n-1'까지의 평균을 재사용하는 알고리즘이다
 
 이러한 알고리즘을 재귀식(Recurrence Expression)이라고 한다. (** 재귀식은 재귀 함수보다 좀 더 포괄적인 개념)
 
 재귀식인 평균 필터 알고리즘을 사용하면 이전에 들어온 데이터를 전부 저장해놓을 필요도 없고, 몇 개의 데이터가 누적되든 반드시 O(1)의 
 시간 복잡도를 보장한다. 따라서 이 알고리즘은 센서에서 짧은 간격으로 들어오는 데이터들을 실시간으로 처리해야 하는 IoT나 임베디드 분야에서 많이 사용된다.
 
 ``` 
 let avg = 0;
function cumulativeAverage (prevAvg, newNumber, listLength) {
  const oldWeight = (listLength - 1) / listLength;
  const newWeight = 1 / listLength;
  return (prevAvg * oldWeight) + (newNumber * newWeight);
}

console.time('avg2');
for (let k = 1; k < 100001; k++) {
  avg = cumulativeAverage(avg, k, k);
}
console.timeEnd('avg2');
console.log(`그래서 평균은? -> ${avg}`);
```

**cumulativeAverage** 함수는 **이전 데이터까지의 평균**과 **새로 들어온 데이터**, **총 데이터 개수** 이렇게 3 개의 인자를 사용하는 함수.

간단한 수식을 통해 바로 평균을 계산한다. 

### 어떤 원리를 사용하는가?

 > Average(n) = (n-1)/n * average(n-1) + (1/n) * Xn
 
 이 식의 n은 현재까지의 전체 데이터 길이, Average(n-1)은 이전 데이터까지의 평균, Xn은 이번에 새로 들어온 데이터를 의미한다.

 이 식에서 중요한 키워드는 바로 **가중치**이다. 우리가 배치식을 버리고 재귀식을 사용하기 위한 조건은 바로 "이전 평균값을 활용"하는 것이다.
 그러기 위해서 새로운 평균을 구하기 위해 사용할 이전 평균값이 새로운 평균값에 끼칠 영향을 계산해줘야 한다.
 
 식을 보면 평균값인 Average(n-1)에 (n-1)/n 이 곱해지고 있다. 이때 (n-1)/n이 의미하는것은 바로 가중치이다. 또 새로 들어온
 Xn을 보면 1/n이 곱해지고 있는데 이 또한 새로운 데이터의 가중치이다.
 
 ```
 const prevData = [1, 2, 3, 4];
 const preAverage = (1 + 2 + 3 + 4) / 4; // 2.5
 ```
 
 여기 길이가 4인 data set이 있다. preAverage는 이전 (1, 2, 3, 4)의 평균값이 2.5이다.
 
 이 때, data set에 5라는 값이 새로 들어오면 배열의 길이는 5가 될것이다. 
 
 배치식을 사용하여 계산하면 1부터 5까지 모두 더한 후 배열의 길이인 5로 나누게 될것이고, 

 재귀식을 사용하면 기존 4개의 원소의 평균이었던 2.5에 가중치인 4/5를 곱해주고 새로 들어온 5에도 가중치인 1/5를 곱한 후 서로 더하기면 하면 된다.
 
 ```
 const batch = (1 + 2 + 3 + 4 + 5) / 5;
 const recurrenced = (2.5 * (4 / 5)) + (5 * (1 / 5));
 console.log(batch, recurrenced); // => 3 3
```
 
결과는 둘 다 **3**으로 동일하게 출력된다. 즉, 쉽게 말하자면 이전 평균값과 새로운 데이터가 평균에서 얼마만큼의 비중을 가지고 있는지
계산해서 더해주는 것이다.


 
 
 
 
 
 
 
 
 
 
 

 
